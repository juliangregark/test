<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitch Stream Text Detector</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        #videoContainer {
            position: relative;
            width: 100%;
            margin-bottom: 20px;
        }
        #twitchFrame {
            width: 100%;
            height: 480px;
            border: none;
        }
        #canvas {
            display: none;
        }
        #captureArea {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80px;
            border: 2px dashed red;
            box-sizing: border-box;
            pointer-events: none;
        }
        #result {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            min-height: 100px;
            background-color: #f9f9f9;
        }
        .controls {
            margin: 15px 0;
        }
        button {
            padding: 8px 16px;
            margin-right: 10px;
            cursor: pointer;
        }
        #confidence {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
        #extractedText {
            font-weight: bold;
        }
        #settings {
            margin: 20px 0;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        .setting {
            margin-bottom: 10px;
        }
        label {
            display: inline-block;
            width: 200px;
        }
    </style>
</head>
<body>
    <h1>Twitch Stream Text Detector</h1>
    
    <div id="settings">
        <div class="setting">
            <label for="captureHeight">Capture Area Height (px):</label>
            <input type="number" id="captureHeight" value="80" min="10" max="200">
        </div>
        <div class="setting">
            <label for="captureInterval">Capture Interval (ms):</label>
            <input type="number" id="captureInterval" value="2000" min="500" max="10000">
        </div>
        <div class="setting">
            <label for="confidenceThreshold">Confidence Threshold (%):</label>
            <input type="number" id="confidenceThreshold" value="60" min="0" max="100">
        </div>
    </div>
    
    <div id="videoContainer">
        <iframe id="twitchFrame" src="https://player.twitch.tv/?channel=crazymangovr&parent=localhost" frameborder="0" allowfullscreen></iframe>
        <div id="captureArea"></div>
    </div>
    
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <button id="startBtn">Start Text Detection</button>
        <button id="stopBtn" disabled>Stop Detection</button>
        <button id="captureBtn">Capture Once</button>
    </div>
    
    <div id="result">
        <h3>Detected Text:</h3>
        <div id="extractedText">No text detected yet...</div>
        <div id="confidence"></div>
        <div id="history"></div>
    </div>

    <script>
        // Initialize Tesseract
        const worker = Tesseract.createWorker();
        
        // DOM elements
        const twitchFrame = document.getElementById('twitchFrame');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const captureArea = document.getElementById('captureArea');
        const extractedText = document.getElementById('extractedText');
        const confidenceElement = document.getElementById('confidence');
        const historyElement = document.getElementById('history');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const captureBtn = document.getElementById('captureBtn');
        
        // Settings
        const captureHeightInput = document.getElementById('captureHeight');
        const captureIntervalInput = document.getElementById('captureInterval');
        const confidenceThresholdInput = document.getElementById('confidenceThreshold');
        
        // Variables
        let captureInterval;
        let isDetecting = false;
        let history = [];
        
        // Update capture area height when setting changes
        captureHeightInput.addEventListener('change', () => {
            captureArea.style.height = `${captureHeightInput.value}px`;
        });
        
        // Initialize Tesseract Worker
        async function initTesseract() {
            await worker.load();
            await worker.loadLanguage('eng');
            await worker.initialize('eng');
            console.log('Tesseract worker initialized');
        }
        
        // Capture frame from Twitch stream
        async function captureFrame() {
            try {
                // Set canvas dimensions
                const frameWidth = twitchFrame.clientWidth;
                const captureHeight = parseInt(captureHeightInput.value);
                canvas.width = frameWidth;
                canvas.height = captureHeight;
                
                // This is a placeholder - in a real implementation, you'd need to capture the actual video frame
                // Note: Due to cross-origin restrictions, you cannot directly access the pixels of an iframe
                // This is just a demonstration of how the logic would work
                
                // For a real implementation, you would need to:
                // 1. Use browser extensions or a proxy server to get around cross-origin restrictions
                // 2. Or use Twitch API to get the stream directly
                
                // For now, let's just demonstrate with a placeholder image
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText('Simulated Twitch Stream Text', 10, 40);
                
                // Process the captured frame
                await processFrame();
            } catch (error) {
                console.error('Error capturing frame:', error);
                extractedText.innerText = 'Error capturing frame';
            }
        }
        
        // Process the captured frame with Tesseract OCR
        async function processFrame() {
            try {
                const imageData = canvas.toDataURL('image/png');
                
                // Recognize text
                const result = await worker.recognize(imageData);
                const confidence = result.data.confidence;
                const text = result.data.text.trim();
                const confidenceThreshold = parseInt(confidenceThresholdInput.value);
                
                // Update UI
                confidenceElement.innerText = `Confidence: ${confidence.toFixed(2)}%`;
                
                if (confidence >= confidenceThreshold && text.length > 0) {
                    extractedText.innerText = text;
                    
                    // Add to history
                    const timestamp = new Date().toLocaleTimeString();
                    history.unshift(`[${timestamp}] ${text}`);
                    if (history.length > 10) history.pop();
                    
                    // Update history display
                    historyElement.innerHTML = '<h4>Recent Detections:</h4>' + 
                        history.map(item => `<div>${item}</div>`).join('');
                } else if (text.length === 0) {
                    extractedText.innerText = 'No text detected';
                } else {
                    extractedText.innerText = `Text detected but below confidence threshold (${confidence.toFixed(2)}%)`;
                }
            } catch (error) {
                console.error('Error processing frame:', error);
                extractedText.innerText = 'Error processing frame';
            }
        }
        
        // Start continuous detection
        function startDetection() {
            if (isDetecting) return;
            isDetecting = true;
            startBtn.disabled = true;
            stopBtn.disabled = false;
            
            const interval = parseInt(captureIntervalInput.value);
            captureFrame(); // Capture immediately
            captureInterval = setInterval(captureFrame, interval);
        }
        
        // Stop continuous detection
        function stopDetection() {
            if (!isDetecting) return;
            isDetecting = false;
            startBtn.disabled = false;
            stopBtn.disabled = true;
            
            clearInterval(captureInterval);
        }
        
        // Event listeners
        startBtn.addEventListener('click', startDetection);
        stopBtn.addEventListener('click', stopDetection);
        captureBtn.addEventListener('click', captureFrame);
        
        // Initialize
        initTesseract();
    </script>
</body>
</html>

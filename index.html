<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marvel Rivals Twitch Stream Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/comfy.js/1.1.10/comfy.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a2e;
            color: #e6e6e6;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #16213e;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #e94560;
            padding-bottom: 20px;
        }
        
        h1 {
            color: #e94560;
            margin: 0;
        }
        
        .logo {
            max-width: 200px;
            margin-bottom: 10px;
        }
        
        .setup-section {
            margin-bottom: 30px;
            background-color: #0f3460;
            padding: 20px;
            border-radius: 8px;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }
        
        .panel {
            background-color: #0f3460;
            border-radius: 8px;
            padding: 15px;
            min-height: 300px;
        }
        
        .panel h3 {
            color: #e94560;
            margin-top: 0;
            border-bottom: 1px solid #e94560;
            padding-bottom: 10px;
        }
        
        input, button {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border: none;
        }
        
        input {
            background-color: #1e2747;
            color: #e6e6e6;
            width: 100%;
            box-sizing: border-box;
        }
        
        button {
            background-color: #e94560;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #c04050;
        }
        
        .chat-message {
            border-bottom: 1px solid #333;
            padding: 8px 0;
        }
        
        .username {
            font-weight: bold;
            color: #5da9e9;
        }
        
        .timestamp {
            color: #888;
            font-size: 0.8em;
            margin-left: 5px;
        }
        
        .highlight {
            background-color: rgba(233, 69, 96, 0.2);
            border-left: 3px solid #e94560;
            padding-left: 5px;
        }
        
        .character-bar {
            background-color: #16213e;
            height: 20px;
            margin: 5px 0;
            border-radius: 3px;
            position: relative;
        }
        
        .character-fill {
            background-color: #e94560;
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease-in-out;
        }
        
        .character-name {
            position: absolute;
            left: 10px;
            top: 0;
            line-height: 20px;
            font-size: 0.9em;
        }
        
        .character-count {
            position: absolute;
            right: 10px;
            top: 0;
            line-height: 20px;
            font-size: 0.9em;
        }
        
        .term-tag {
            display: inline-block;
            background-color: #0f3460;
            padding: 5px 10px;
            margin: 3px;
            border-radius: 15px;
            font-size: 0.9em;
        }
        
        .control-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .control-row button {
            flex: 1;
        }
        
        .status {
            font-weight: bold;
            margin: 10px 0;
        }
        
        .connected {
            color: #4CAF50;
        }
        
        .disconnected {
            color: #e94560;
        }
        
        #chat-messages {
            height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }
        
        #new-term-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <img src="/api/placeholder/200/100" alt="Marvel Rivals Logo" class="logo">
            <h1>Marvel Rivals Twitch Stream Analyzer</h1>
            <p>Monitor and analyze Marvel Rivals gameplay discussions in Twitch chat</p>
        </header>
        
        <div class="setup-section">
            <h2>Connect to Twitch</h2>
            <div>
                <label for="channel-input">Channel Name:</label>
                <input type="text" id="channel-input" placeholder="Enter Twitch channel name">
            </div>
            <div>
                <label for="oauth-input">OAuth Token:</label>
                <input type="password" id="oauth-input" placeholder="oauth:your_token_here">
                <p><small>Get your OAuth token from <a href="https://twitchapps.com/tmi/" target="_blank" style="color: #e94560;">twitchapps.com/tmi/</a></small></p>
            </div>
            <div>
                <label for="username-input">Your Twitch Username (optional):</label>
                <input type="text" id="username-input" placeholder="Your Twitch username">
            </div>
            <div class="control-row">
                <button id="connect-btn">Connect</button>
                <button id="disconnect-btn" disabled>Disconnect</button>
            </div>
            <div id="connection-status" class="status disconnected">Status: Disconnected</div>
        </div>
        
        <div class="dashboard">
            <div class="panel">
                <h3>Live Chat</h3>
                <div id="chat-messages"></div>
            </div>
            
            <div class="panel">
                <h3>Character Popularity</h3>
                <div id="character-stats"></div>
            </div>
            
            <div class="panel">
                <h3>Gameplay Terms</h3>
                <div id="gameplay-terms"></div>
                
                <div id="new-term-section">
                    <h4>Add New Term to Track</h4>
                    <select id="term-category">
                        <option value="characters">Character</option>
                        <option value="gameplay">Gameplay Term</option>
                        <option value="maps">Map</option>
                    </select>
                    <input type="text" id="new-term" placeholder="Enter new term to track">
                    <button id="add-term-btn">Add Term</button>
                </div>
            </div>
            
            <div class="panel">
                <h3>Gameplay Tips</h3>
                <div id="gameplay-tips"></div>
            </div>
            
            <div class="panel">
                <h3>Video Recognition</h3>
                <div class="control-row">
                    <button id="start-recognition-btn">Start Video Recognition</button>
                    <button id="stop-recognition-btn" disabled>Stop Recognition</button>
                </div>
                <div id="recognition-status" class="status disconnected">Video Recognition: Inactive</div>
                <div id="video-preview" style="margin-top: 10px; width: 100%; height: 200px; background: #111; display: flex; align-items: center; justify-content: center;">
                    <span>Video preview will appear here when active</span>
                </div>
                <h4>Detection Stats</h4>
                <div id="detection-stats"></div>
            </div>
            
            <div class="panel">
                <h3>Game State Timeline</h3>
                <div id="game-timeline"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.1.0/tf.min.js"></script>
    <script>
        // Marvel Rivals Twitch Analyzer
        
        // Data structures
        const marvelRivalsTerms = {
            characters: [
                "Iron Man", "Captain America", "Black Panther", "Storm", "Magik", "Magneto", 
                "Hulk", "Spider-Man", "Doctor Strange", "Luna Snow", "Peni Parker", "Rocket Raccoon",
                "Star-Lord", "Groot", "Mantis", "Adam Warlock", "Hela", "Namor", "Loki"
            ],
            gameplay: [
                "ultimate", "ability", "cooldown", "combo", "team fight", "objective", 
                "map control", "positioning", "rotation", "push", "counter", "build", 
                "meta", "nerf", "buff", "patch", "update", "strategy", "team comp"
            ],
            maps: [
                "Avengers Tower", "Asgard", "Wakanda", "Sakaar Arena"
            ]
        };
        
        const learnedData = {
            characterPopularity: {},
            commonTerms: {},
            userEngagement: {},
            gameplayTips: [],
            videoDetections: {
                characters: {},
                gameStates: [],
                timeline: []
            }
        };
        
        // Initialize character counts
        marvelRivalsTerms.characters.forEach(character => {
            learnedData.characterPopularity[character] = 0;
            // Initialize video detection counts too
            learnedData.videoDetections.characters[character] = {
                count: 0,
                screenTime: 0,
                lastSeen: null
            };
        });
        
        // DOM Elements
        const channelInput = document.getElementById('channel-input');
        const oauthInput = document.getElementById('oauth-input');
        const usernameInput = document.getElementById('username-input');
        const connectBtn = document.getElementById('connect-btn');
        const disconnectBtn = document.getElementById('disconnect-btn');
        const connectionStatus = document.getElementById('connection-status');
        const chatMessages = document.getElementById('chat-messages');
        const characterStats = document.getElementById('character-stats');
        const gameplayTerms = document.getElementById('gameplay-terms');
        const gameplayTips = document.getElementById('gameplay-tips');
        const termCategory = document.getElementById('term-category');
        const newTermInput = document.getElementById('new-term');
        const addTermBtn = document.getElementById('add-term-btn');
        const startRecognitionBtn = document.getElementById('start-recognition-btn');
        const stopRecognitionBtn = document.getElementById('stop-recognition-btn');
        const recognitionStatus = document.getElementById('recognition-status');
        const videoPreview = document.getElementById('video-preview');
        const detectionStats = document.getElementById('detection-stats');
        const gameTimeline = document.getElementById('game-timeline');
        
        // Connection state
        let isConnected = false;
        let videoRecognition = null;
        
        // Connect to Twitch
        connectBtn.addEventListener('click', () => {
            const channel = channelInput.value.trim();
            const oauth = oauthInput.value.trim();
            const username = usernameInput.value.trim();
            
            if (!channel) {
                alert('Please enter a channel name');
                return;
            }
            
            if (!oauth || !oauth.startsWith('oauth:')) {
                alert('Please enter a valid OAuth token starting with "oauth:"');
                return;
            }
            
            // Connect to Twitch chat
            ComfyJS.Init(username || null, oauth, channel);
            
            isConnected = true;
            connectionStatus.textContent = 'Status: Connected to ' + channel;
            connectionStatus.className = 'status connected';
            
            connectBtn.disabled = true;
            disconnectBtn.disabled = false;
            
            // Log connection
            addChatMessage('System', 'Connected to channel: ' + channel, true);
        });
        
        // Disconnect from Twitch
        disconnectBtn.addEventListener('click', () => {
            ComfyJS.Disconnect();
            
            isConnected = false;
            connectionStatus.textContent = 'Status: Disconnected';
            connectionStatus.className = 'status disconnected';
            
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            
            // Log disconnection
            addChatMessage('System', 'Disconnected from Twitch chat', true);
        });
        
        // Add new term to track
        addTermBtn.addEventListener('click', () => {
            const category = termCategory.value;
            const term = newTermInput.value.trim();
            
            if (!term) {
                alert('Please enter a term to track');
                return;
            }
            
            if (marvelRivalsTerms[category].includes(term)) {
                alert(`"${term}" is already being tracked in the ${category} category`);
                return;
            }
            
            marvelRivalsTerms[category].push(term);
            
            if (category === 'characters') {
                learnedData.characterPopularity[term] = 0;
                updateCharacterStats();
            }
            
            addChatMessage('System', `Now tracking "${term}" in ${category} category`, true);
            newTermInput.value = '';
        });
        
        // Process chat messages
        function processMessage(user, message, flags, self) {
            // Track character mentions
            marvelRivalsTerms.characters.forEach(character => {
                if (message.toLowerCase().includes(character.toLowerCase())) {
                    learnedData.characterPopularity[character]++;
                    updateCharacterStats();
                }
            });
            
            // Track gameplay terms
            marvelRivalsTerms.gameplay.forEach(term => {
                if (message.toLowerCase().includes(term.toLowerCase())) {
                    learnedData.commonTerms[term] = (learnedData.commonTerms[term] || 0) + 1;
                    updateGameplayTerms();
                }
            });
            
            // Track user engagement
            learnedData.userEngagement[user] = (learnedData.userEngagement[user] || 0) + 1;
            
            // Look for potential gameplay tips
            if (message.toLowerCase().includes("tip") || 
                message.toLowerCase().includes("advice") || 
                message.toLowerCase().includes("strategy")) {
                learnedData.gameplayTips.push({
                    user: user,
                    message: message,
                    timestamp: new Date().toISOString()
                });
                updateGameplayTips();
            }
        }
        
        // Initialize and handle video recognition
        async function initializeVideoRecognition() {
            try {
                // Create video recognition instance
                videoRecognition = new MarvelRivalsVideoRecognition({
                    captureInterval: 3000, // Capture every 3 seconds
                    debug: true, // Show debug information
                    onDetection: handleVideoDetection
                });
                
                // Initialize the video recognition
                const success = await videoRecognition.initialize();
                
                if (success) {
                    startRecognitionBtn.disabled = false;
                    addChatMessage('System', 'Video recognition module initialized successfully', true);
                } else {
                    addChatMessage('System', 'Failed to initialize video recognition', true);
                }
            } catch (error) {
                console.error("Error initializing video recognition:", error);
                addChatMessage('System', 'Error initializing video recognition: ' + error.message, true);
            }
        }
        
        // Handle video detection events
        function handleVideoDetection(detection) {
            // Add to timeline
            learnedData.videoDetections.timeline.push({
                type: detection.type,
                label: detection.label,
                confidence: detection.confidence,
                timestamp: new Date().toISOString()
            });
            
            // Update the appropriate stats based on detection type
            if (detection.type === 'character') {
                if (!learnedData.videoDetections.characters[detection.label]) {
                    learnedData.videoDetections.characters[detection.label] = {
                        count: 0,
                        screenTime: 0,
                        lastSeen: null
                    };
                }
                
                learnedData.videoDetections.characters[detection.label].count++;
                learnedData.videoDetections.characters[detection.label].lastSeen = new Date().toISOString();
                
                // Also update chat-based stats to combine both sources
                learnedData.characterPopularity[detection.label] = 
                    (learnedData.characterPopularity[detection.label] || 0) + 1;
                
                updateCharacterStats();
            } else if (detection.type === 'gameState') {
                // Add to game state detections
                learnedData.videoDetections.gameStates.push({
                    state: detection.label,
                    confidence: detection.confidence,
                    timestamp: new Date().toISOString()
                });
                
                updateGameTimeline();
            }
            
            // Update the detection stats display
            updateDetectionStats();
        }
        
        // Start video recognition
        function startVideoRecognition() {
            if (!videoRecognition) {
                addChatMessage('System', 'Video recognition module not initialized', true);
                return;
            }
            
            const success = videoRecognition.startCapturing();
            
            if (success) {
                recognitionStatus.textContent = 'Video Recognition: Active';
                recognitionStatus.className = 'status connected';
                startRecognitionBtn.disabled = true;
                stopRecognitionBtn.disabled = false;
                
                // Move video preview to the preview area
                if (videoRecognition.canvasElement) {
                    videoPreview.innerHTML = '';
                    const previewCanvas = document.createElement('canvas');
                    previewCanvas.width = 320;
                    previewCanvas.height = 180;
                    previewCanvas.style.width = '100%';
                    previewCanvas.style.height = 'auto';
                    previewCanvas.style.border = '1px solid #333';
                    
                    videoPreview.appendChild(previewCanvas);
                    
                    // Update preview canvas every second
                    const previewContext = previewCanvas.getContext('2d');
                    const updatePreview = () => {
                        if (videoRecognition.canvasElement) {
                            previewContext.drawImage(videoRecognition.canvasElement, 0, 0, previewCanvas.width, previewCanvas.height);
                            if (videoRecognition.isCapturing) {
                                requestAnimationFrame(updatePreview);
                            }
                        }
                    };
                    
                    updatePreview();
                }
                
                addChatMessage('System', 'Video recognition started', true);
            } else {
                addChatMessage('System', 'Failed to start video recognition', true);
            }
        }
        
        // Stop video recognition
        function stopVideoRecognition() {
            if (!videoRecognition) return;
            
            videoRecognition.stopCapturing();
            recognitionStatus.textContent = 'Video Recognition: Inactive';
            recognitionStatus.className = 'status disconnected';
            startRecognitionBtn.disabled = false;
            stopRecognitionBtn.disabled = true;
            
            videoPreview.innerHTML = '<span>Video preview will appear here when active</span>';
            
            addChatMessage('System', 'Video recognition stopped', true);
        }
        
        // Update detection stats display
        function updateDetectionStats() {
            detectionStats.innerHTML = '';
            
            // Characters section
            const charactersDiv = document.createElement('div');
            charactersDiv.innerHTML = '<h4>Characters Detected:</h4>';
            
            const characterEntries = Object.entries(learnedData.videoDetections.characters)
                .filter(([_, data]) => data.count > 0)
                .sort((a, b) => b[1].count - a[1].count);
            
            if (characterEntries.length > 0) {
                const charactersList = document.createElement('ul');
                charactersList.style.paddingLeft = '20px';
                
                characterEntries.slice(0, 5).forEach(([character, data]) => {
                    const item = document.createElement('li');
                    item.textContent = `${character}: ${data.count} detections`;
                    charactersList.appendChild(item);
                });
                
                charactersDiv.appendChild(charactersList);
            } else {
                charactersDiv.innerHTML += '<p>No characters detected yet</p>';
            }
            
            // Game states section
            const statesDiv = document.createElement('div');
            statesDiv.innerHTML = '<h4>Recent Game States:</h4>';
            
            const recentStates = learnedData.videoDetections.gameStates.slice(-5).reverse();
            
            if (recentStates.length > 0) {
                const statesList = document.createElement('ul');
                statesList.style.paddingLeft = '20px';
                
                recentStates.forEach(state => {
                    const item = document.createElement('li');
                    item.textContent = `${state.state} (${new Date(state.timestamp).toLocaleTimeString()})`;
                    statesList.appendChild(item);
                });
                
                statesDiv.appendChild(statesList);
            } else {
                statesDiv.innerHTML += '<p>No game states detected yet</p>';
            }
            
            detectionStats.appendChild(charactersDiv);
            detectionStats.appendChild(statesDiv);
        }
        
        // Update game timeline display
        function updateGameTimeline() {
            gameTimeline.innerHTML = '';
            
            // Create timeline
            const timeline = document.createElement('div');
            timeline.className = 'timeline';
            timeline.style.position = 'relative';
            timeline.style.height = '150px';
            timeline.style.marginTop = '20px';
            timeline.style.border = '1px solid #333';
            timeline.style.borderRadius = '5px';
            timeline.style.padding = '10px';
            timeline.style.overflowY = 'auto';
            
            // Add timeline line
            const line = document.createElement('div');
            line.style.position = 'absolute';
            line.style.left = '100px';
            line.style.top = '0';
            line.style.bottom = '0';
            line.style.width = '2px';
            line.style.backgroundColor = '#555';
            timeline.appendChild(line);
            
            // Add events to timeline
            const events = learnedData.videoDetections.timeline.slice(-20).reverse();
            
            events.forEach((event, index) => {
                const eventDiv = document.createElement('div');
                eventDiv.className = 'timeline-event';
                eventDiv.style.position = 'relative';
                eventDiv.style.marginBottom = '10px';
                eventDiv.style.paddingLeft = '110px';
                
                const dot = document.createElement('div');
                dot.style.position = 'absolute';
                dot.style.left = '98px';
                dot.style.top = '5px';
                dot.style.width = '6px';
                dot.style.height = '6px';
                dot.style.borderRadius = '50%';
                dot.style.backgroundColor = event.type === 'character' ? '#e94560' : '#5da9e9';
                
                const time = document.createElement('div');
                time.className = 'timeline-time';
                time.style.position = 'absolute';
                time.style.left = '0';
                time.style.top = '0';
                time.style.width = '90px';
                time.style.textAlign = 'right';
                time.style.paddingRight = '10px';
                time.style.fontSize = '0.8em';
                time.style.color = '#aaa';
                time.textContent = new Date(event.timestamp).toLocaleTimeString();
                
                const content = document.createElement('div');
                content.className = 'timeline-content';
                content.textContent = `${event.type === 'character' ? 'ðŸ‘¤' : 'ðŸŽ®'} ${event.label}`;
                
                eventDiv.appendChild(dot);
                eventDiv.appendChild(time);
                eventDiv.appendChild(content);
                
                timeline.appendChild(eventDiv);
            });
            
            gameTimeline.appendChild(timeline);
        }
        
        // Add chat message to the UI
        function addChatMessage(user, message, isSystem = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message' + (isSystem ? ' highlight' : '');
            
            const timestamp = document.createElement('span');
            timestamp.className = 'timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();
            
            const username = document.createElement('span');
            username.className = 'username';
            username.textContent = user + ': ';
            
            const content = document.createElement('span');
            content.textContent = message;
            
            messageDiv.appendChild(username);
            messageDiv.appendChild(content);
            messageDiv.appendChild(timestamp);
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Keep only the last 100 messages
            while (chatMessages.children.length > 100) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
        }
        
        // Update character popularity stats
        function updateCharacterStats() {
            characterStats.innerHTML = '';
            
            // Get sorted characters by popularity
            const sortedCharacters = Object.entries(learnedData.characterPopularity)
                .sort((a, b) => b[1] - a[1]);
            
            // Find the maximum count for scaling
            const maxCount = Math.max(...sortedCharacters.map(entry => entry[1]), 1);
            
            // Create bar for each character
            sortedCharacters.forEach(([character, count]) => {
                if (count === 0) return; // Skip characters with no mentions
                
                const percentage = (count / maxCount) * 100;
                
                const charDiv = document.createElement('div');
                charDiv.className = 'character-stat';
                
                const barContainer = document.createElement('div');
                barContainer.className = 'character-bar';
                
                const bar = document.createElement('div');
                bar.className = 'character-fill';
                bar.style.width = `${percentage}%`;
                
                const nameLabel = document.createElement('div');
                nameLabel.className = 'character-name';
                nameLabel.textContent = character;
                
                const countLabel = document.createElement('div');
                countLabel.className = 'character-count';
                countLabel.textContent = count;
                
                barContainer.appendChild(bar);
                barContainer.appendChild(nameLabel);
                barContainer.appendChild(countLabel);
                
                charDiv.appendChild(barContainer);
                characterStats.appendChild(charDiv);
            });
        }
        
        // Update gameplay terms
        function updateGameplayTerms() {
            gameplayTerms.innerHTML = '';
            
            const sortedTerms = Object.entries(learnedData.commonTerms)
                .sort((a, b) => b[1] - a[1]);
            
            sortedTerms.forEach(([term, count]) => {
                const termDiv = document.createElement('span');
                termDiv.className = 'term-tag';
                termDiv.textContent = `${term} (${count})`;
                
                gameplayTerms.appendChild(termDiv);
            });
        }
        
        // Update gameplay tips
        function updateGameplayTips() {
            gameplayTips.innerHTML = '';
            
            // Show the 5 most recent tips
            const recentTips = learnedData.gameplayTips.slice(-5).reverse();
            
            recentTips.forEach(tip => {
                const tipDiv = document.createElement('div');
                tipDiv.className = 'chat-message';
                
                const timestamp = document.createElement('span');
                timestamp.className = 'timestamp';
                timestamp.textContent = new Date(tip.timestamp).toLocaleTimeString();
                
                const username = document.createElement('span');
                username.className = 'username';
                username.textContent = tip.user + ': ';
                
                const content = document.createElement('span');
                content.textContent = tip.message;
                
                tipDiv.appendChild(username);
                tipDiv.appendChild(content);
                tipDiv.appendChild(timestamp);
                
                gameplayTips.appendChild(tipDiv);
            });
        }
        
        // Set up ComfyJS event handlers
        ComfyJS.onChat = (user, message, flags, self, extra) => {
            addChatMessage(user, message);
            processMessage(user, message, flags, self);
        };
        
        ComfyJS.onCheer = (user, message, bits, flags, extra) => {
            addChatMessage(user, `[${bits} bits] ${message}`);
            processMessage(user, message, flags, false);
        };
        
        ComfyJS.onSub = (user, message, subTierInfo, extra) => {
            addChatMessage(user, `[NEW SUB] ${message}`);
        };
        
        ComfyJS.onResub = (user, message, streamMonths, cumulativeMonths, subTierInfo, extra) => {
            addChatMessage(user, `[RESUB ${cumulativeMonths} months] ${message}`);
        };
        
        ComfyJS.onRaid = (user, viewers, extra) => {
            addChatMessage('System', `${user} raided with ${viewers} viewers!`, true);
        };
        
        ComfyJS.onConnect = () => {
            connectionStatus.textContent = 'Status: Connected';
            connectionStatus.className = 'status connected';
        };
        
        ComfyJS.onDisconnect = () => {
            if (isConnected) {
                connectionStatus.textContent = 'Status: Reconnecting...';
            } else {
                connectionStatus.textContent = 'Status: Disconnected';
                connectionStatus.className = 'status disconnected';
            }
        };
        
        ComfyJS.onError = (error) => {
            console.error("ComfyJS Error:", error);
            addChatMessage('System', `Error: ${error}`, true);
        };
        
        // Set up video recognition event handlers
        startRecognitionBtn.addEventListener('click', startVideoRecognition);
        stopRecognitionBtn.addEventListener('click', stopVideoRecognition);
        
        // Define the MarvelRivalsVideoRecognition class
        class MarvelRivalsVideoRecognition {
            constructor(options = {}) {
                // Configuration with defaults
                this.config = {
                    captureInterval: options.captureInterval || 2000, // ms between captures
                    confidenceThreshold: options.confidenceThreshold || 0.7,
                    debug: options.debug || false,
                    onDetection: options.onDetection || function() {},
                    modelPath: options.modelPath || 'models/marvel-rivals-model'
                };
                
                // State
                this.isCapturing = false;
                this.captureTimer = null;
                this.videoElement = null;
                this.canvasElement = null;
                this.canvasContext = null;
                this.model = null;
                this.characterDetections = {};
                this.gameStateDetections = {};
                
                // Recognition data
                this.characterTemplates = {};
                marvelRivalsTerms.characters.forEach(character => {
                    this.characterTemplates[character] = {
                        regions: ["hero_portrait", "ability_icons"],
                        color_profile: [
                            Math.floor(Math.random() * 255),
                            Math.floor(Math.random() * 255),
                            Math.floor(Math.random() * 255)
                        ]
                    };
                });
                
                this.gameStateTemplates = {
                    "Match Start": { regions: ["center_screen"], templates: ["vs_screen", "character_select"] },
                    "Ultimate Ready": { regions: ["ultimate_indicator"], color_profile: [255, 200, 0] },
                    "Low Health": { regions: ["health_bar"], color_profile: [255, 0, 0] },
                    "Victory": { regions: ["center_screen"], templates: ["victory_text", "win_pose"] },
                    "Defeat": { regions: ["center_screen"], templates: ["defeat_text", "lose_pose"] },
                    "Team Fight": { regions: ["minimap"], density_threshold: 0.6 },
                    "Objective Capture": { regions: ["objective_indicator"], templates: ["capture_progress"] }
                };
            }
            
            async initialize() {
                try {
                    // Create canvas for processing
                    this.canvasElement = document.createElement('canvas');
                    this.canvasElement.width = 640;
                    this.canvasElement.height = 360;
                    this.canvasContext = this.canvasElement.getContext('2d');
                    
                    // Create or get video element
                    this.createVideoElement();
                    
                    if (this.config.debug) {
                        // Add canvas to document for debugging
                        this.canvasElement.style.position = 'fixed';
                        this.canvasElement.style.bottom = '10px';
                        this.canvasElement.style.right = '10px';
                        this.canvasElement.style.border = '2px solid red';
                        this.canvasElement.style.width = '320px';
                        this.canvasElement.style.height = '180px';
                        this.canvasElement.style.zIndex = '9999';
                        document.body.appendChild(this.canvasElement);
                    }
                    
                    // Simulated model initialization
                    this.model = {
                        detect: (imageData) => this.simulateDetection(imageData)
                    };
                    
                    console.log("Marvel Rivals Video Recognition initialized");
                    return true;
                } catch (error) {
                    console.error("Failed to initialize video recognition:", error);
                    return false;
                }
            }
            
            createVideoElement() {
                // Check if we already have a video element we can use
                const twitchVideo = document.querySelector('.video-player__container video');
                
                if (twitchVideo) {
                    console.log("Found existing Twitch video player");
                    this.videoElement = twitchVideo;
                } else {
                    console.log("Creating new video element for stream capture");
                    // Create a hidden video element
                    this.videoElement = document.createElement('video');
                    this.videoElement.setAttribute('autoplay', true);
                    this.videoElement.setAttribute('playsinline', true);
                    this.videoElement.style.display = 'none';
                    document.body.appendChild(this.videoElement);
                    
                    // For simulation, create a dummy video canvas
                    const dummyCanvas = document.createElement('canvas');
                    dummyCanvas.width = 640;
                    dummyCanvas.height = 360;
                    const ctx = dummyCanvas.getContext('2d');
                    
                    // Create some random content for simulation
                    setInterval(() => {
                        // Clear canvas
                        ctx.fillStyle = '#111';
                        ctx.fillRect(0, 0, dummyCanvas.width, dummyCanvas.height);
                        
                        // Draw some random shapes to simulate game content
                        for (let i = 0; i < 5; i++) {
                            ctx.fillStyle = `rgb(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255})`;
                            ctx.fillRect(
                                Math.random() * dummyCanvas.width,
                                Math.random() * dummyCanvas.height,
                                Math.random() * 100 + 50,
                                Math.random() * 100 + 50
                            );
                        }
                        
                        // Simulate character portrait
                        ctx.fillStyle = '#333';
                        ctx.fillRect(20, 20, 100, 100);
                        
                    }, 1000);
                    
                    // Use this canvas as our source
                    this.simulationCanvas = dummyCanvas;
                }
            }
            
            startCapturing() {
                if (this.isCapturing) {
                    console.log("Already capturing");
                    return true;
                }
                
                this.isCapturing = true;
                this.captureFrame();
                console.log("Started capture with interval:", this.config.captureInterval);
                return true;
            }
            
            stopCapturing() {
                this.isCapturing = false;
                if (this.captureTimer) {
                    clearTimeout(this.captureTimer);
                    this.captureTimer = null;
                }
                console.log("Stopped capture");
            }
            
            captureFrame() {
                if (!this.isCapturing) return;
                
                try {
                    // For real implementation, capture from video
                    if (this.videoElement && this.videoElement.readyState >= 2) {
                        this.canvasContext.drawImage(
                            this.videoElement, 
                            0, 0, 
                            this.canvasElement.width, 
                            this.canvasElement.height
                        );
                    } 
                    // For simulation
                    else if (this.simulationCanvas) {
                        this.canvasContext.drawImage(
                            this.simulationCanvas, 
                            0, 0, 
                            this.canvasElement.width, 
                            this.canvasElement.height
                        );
                    }
                    
                    // Process the frame
                    this.processFrame();
                } catch (error) {
                    console.error("Error capturing frame:", error);
                }
                
                // Schedule next capture
                this.captureTimer = setTimeout(() => this.captureFrame(), this.config.captureInterval);
            }
            
            processFrame() {
                // Get the image data from the canvas
                const imageData = this.canvasContext.getImageData(
                    0, 0, 
                    this.canvasElement.width, 
                    this.canvasElement.height
                );
                
                // Run detection
                this.runDetection(imageData);
            }
            
            async runDetection(imageData) {
                try {
                    // In a real implementation, this would pass the image to TensorFlow.js
                    const detections = await this.model.detect(imageData);
                    
                    if (detections && detections.length > 0) {
                        // Process the results
                        detections.forEach(detection => {
                            if (detection.confidence >= this.config.confidenceThreshold) {
                                // Call the detection callback
                                this.config.onDetection(detection);
                                
                                if (this.config.debug) {
                                    this.drawDetectionOnCanvas(detection);
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error("Detection error:", error);
                }
            }
            
            drawDetectionOnCanvas(detection) {
                // Draw bounding box for debugging
                this.canvasContext.strokeStyle = 'red';
                this.canvasContext.lineWidth = 2;
                this.canvasContext.strokeRect(
                    detection.bbox[0],
                    detection.bbox[1],
                    detection.bbox[2],
                    detection.bbox[3]
                );
                
                // Draw label
                this.canvasContext.fillStyle = 'red';
                this.canvasContext.font = '16px Arial';
                this.canvasContext.fillText(
                    `${detection.label} (${Math.round(detection.confidence * 100)}%)`,
                    detection.bbox[0],
                    detection.bbox[1] > 20 ? detection.bbox[1] - 5 : detection.bbox[1] + 20
                );
            }
            
            // Simulate detection for testing purposes
            simulateDetection(imageData) {
                // Simulate detection with randomness for demonstration
                const detections = [];
                
                // Random character detection (10% chance)
                if (Math.random() < 0.1) {
                    const characters = Object.keys(this.characterTemplates);
                    const randomCharacter = characters[Math.floor(Math.random() * characters.length)];
                    
                    detections.push({
                        type: 'character',
                        label: randomCharacter,
                        confidence: 0.7 + (Math.random() * 0.3),
                        bbox: [
                            Math.floor(Math.random() * (this.canvasElement.width - 100)),
                            Math.floor(Math.random() * (this.canvasElement.height - 100)),
                            100,
                            100
                        ]
                    });
                }
                
                // Random game state detection (5% chance)
                if (Math.random() < 0.05) {
                    const gameStates = Object.keys(this.gameStateTemplates);
                    const randomState = gameStates[Math.floor(Math.random() * gameStates.length)];
                    
                    detections.push({
                        type: 'gameState',
                        label: randomState,
                        confidence: 0.7 + (Math.random() * 0.3),
                        bbox: [
                            Math.floor(Math.random() * (this.canvasElement.width - 150)),
                            Math.floor(Math.random() * (this.canvasElement.height - 50)),
                            150,
                            50
                        ]
                    });
                }
                
                return detections;
            }
        }
        
        // Initial UI updates
        updateCharacterStats();
        updateGameplayTerms();
        updateGameplayTips();
        
        // Initialize video recognition
        initializeVideoRecognition();
    </script>
</body>
</html>
